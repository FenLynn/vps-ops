services:
  # 1. Certificate Manager (Wildcard)
  acme:
    env_file: ../.env
    image: ${ACME_IMAGE:-neilpang/acme.sh:latest}
    container_name: acme.sh
    restart: unless-stopped
    command: daemon
    volumes:
      - ${DOCKER_ROOT:-/nfs/docker}/global/certs:/acme.sh
    environment:
      - CF_Token=${CF_DNS_API_TOKEN:-dummy_token}
      - CF_Account_ID=${CLOUDFLARE_ACCOUNT_ID:-dummy_id}
    network_mode: host

  # 2. Ingress Tunnel (Public Access)
  cloudflared:
    env_file: ../.env
    image: hub.rat.dev/cloudflare/cloudflared:latest
    container_name: cloudflared
    restart: unless-stopped
    command: tunnel run --token ${CF_TOKEN:-dummy_token}
    networks:
      - vps-net

  # 3. Auto-Updater
  watchtower:
    env_file: ../.env
    image: hub.rat.dev/containrrr/watchtower:latest
    container_name: watchtower
    restart: unless-stopped
    environment:
      - WATCHTOWER_CLEANUP=true
      - WATCHTOWER_SCHEDULE=0 0 4 * * *  # 4 AM Daily
      - DOCKER_API_VERSION=1.44
      # Notifications via PushPlus (Shoutrrr format)
      - WATCHTOWER_NOTIFICATION_URL=${WATCHTOWER_NOTIFICATION_URL:-}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

  # 4. Mandatory Cert Generator (First-run automation)
  acme-init:
    env_file: ../.env
    image: ${ACME_IMAGE:-neilpang/acme.sh:latest}
    container_name: acme-init
    depends_on:
      - acme
    volumes:
      - ${DOCKER_ROOT:-/nfs/docker}/global/certs:/acme.sh
    environment:
      - CF_Token=${CF_DNS_API_TOKEN:-dummy_token}
      - DERP_DOMAIN=${DERP_DOMAIN:-localhost}
    network_mode: host
    command: |
      /bin/sh -c "
      sleep 10;
      if [ ! -s /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.crt ] || ! grep -q 'BEGIN CERTIFICATE' /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.crt; then
        echo 'ðŸš€ Issuing/Repairing certificate for \$DERP_DOMAIN...';
        rm -rf /acme.sh/\$DERP_DOMAIN/*;
        /entry.sh --issue --server letsencrypt -d \$DERP_DOMAIN --dns dns_cf --keylength ec-256;
        # Ensure target dir exists
        mkdir -p /acme.sh/\$DERP_DOMAIN;
        # Install (attempt standard)
        /entry.sh --install-cert -d \$DERP_DOMAIN --ecc --cert-file /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.crt --key-file /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.key;
        # FALLBACK: Force copy from _ecc folder if standard install was quirky
        if [ ! -s /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.crt ]; then
            echo 'âš ï¸ Standard install missed, forcing copy from ECC folder...';
            # Try to copy .cer or .crt from _ecc folder and rename to .crt
            cp -f /acme.sh/\${DERP_DOMAIN}_ecc/\${DERP_DOMAIN}.cer /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.crt 2>/dev/null || true;
            cp -f /acme.sh/\${DERP_DOMAIN}_ecc/\${DERP_DOMAIN}.crt /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.crt 2>/dev/null || true;
            # Also copy key
            cp -f /acme.sh/\${DERP_DOMAIN}_ecc/\${DERP_DOMAIN}.key /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.key 2>/dev/null || true;
        fi
        # DEBUG: List final files
        echo "ðŸ“‚ Final certificate directory content:"
        ls -la /acme.sh/\$DERP_DOMAIN/
      else
        echo 'âœ… Valid certificate for \$DERP_DOMAIN exists.';
      fi;
      chmod 644 /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.crt 2>/dev/null || true;
      chmod 644 /acme.sh/\$DERP_DOMAIN/\$DERP_DOMAIN.key 2>/dev/null || true;
      "

networks:
  vps-net:
    external: true
